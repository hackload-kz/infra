/**
 * Cost Tracking Service
 * 
 * Monitors and tracks infrastructure costs for hackathon teams.
 * Provides informational cost breakdowns and budget awareness.
 * Initially supports manual data collection with future extensibility
 * for cloud provider APIs (AWS, Azure, GCP).
 */

import { BaseJobService } from './base-service';
import { CriteriaUpdate, ServiceConfig, ServiceStatus } from '../types';
import { config } from '../config';

export interface CostBreakdown {
  compute: number;        // Computing resources (VMs, containers)
  storage: number;        // Storage costs (disks, databases)
  networking: number;     // Network transfer and load balancer costs
  database: number;       // Database service costs
  monitoring: number;     // Monitoring and logging costs
  other: number;         // Other miscellaneous costs
  total: number;         // Total cost
}

export interface TeamCostData {
  teamId: number;
  teamName: string;
  period: {
    start: Date;
    end: Date;
  };
  costBreakdown: CostBreakdown;
  budgetLimit?: number;   // Optional budget limit
  currency: string;       // Currency code (USD, EUR, etc.)
  lastUpdated: Date;
  dataSource: 'manual' | 'aws' | 'azure' | 'gcp' | 'hybrid';
}

export interface CostTrackingMetrics {
  teamsTracked: number;
  totalCosts: number;
  averageCostPerTeam: number;
  teamsOverBudget: number;
  lastUpdateDuration: number;
  dataSourceBreakdown: Record<string, number>;
}

export interface CloudProviderConfig {
  aws?: {
    accessKeyId?: string;
    secretAccessKey?: string;
    region?: string;
  };
  azure?: {
    clientId?: string;
    clientSecret?: string;
    tenantId?: string;
    subscriptionId?: string;
  };
  gcp?: {
    serviceAccountKey?: string;
    projectId?: string;
  };
}

/**
 * Cost Tracking Service Implementation
 */
export class CostTrackingService extends BaseJobService {
  private metrics: CostTrackingMetrics;
  private cloudConfig: CloudProviderConfig;
  private readonly defaultBudgetLimit: number = 100; // $100 default budget per team

  constructor() {
    const serviceConfig: ServiceConfig = {
      name: 'CostTrackingService',
      enabled: config.services.costTrackingEnabled,
      interval: config.scheduling.costTracking.interval,
      timeout: config.scheduling.costTracking.timeout,
      retries: config.scheduling.costTracking.retries
    };

    super(serviceConfig);
    
    this.metrics = {
      teamsTracked: 0,
      totalCosts: 0,
      averageCostPerTeam: 0,
      teamsOverBudget: 0,
      lastUpdateDuration: 0,
      dataSourceBreakdown: {}
    };

    // Initialize cloud provider configurations
    this.cloudConfig = this.initializeCloudConfig();

    this.logger.info('Cost Tracking Service initialized', {
      enabled: this.config.enabled,
      cloudProvidersConfigured: Object.keys(this.cloudConfig).length,
      defaultBudgetLimit: this.defaultBudgetLimit
    });
  }

  async collectMetrics(): Promise<CriteriaUpdate[]> {
    const startTime = Date.now();
    this.logger.info('Starting cost tracking collection');

    try {
      // Get teams from Hub API
      const teams = await this.apiClient.getTeams();
      this.logger.info(`Collecting cost data for ${teams.length} teams`);

      const updates: CriteriaUpdate[] = [];
      const costData: TeamCostData[] = [];
      
      let totalCosts = 0;
      let teamsOverBudget = 0;
      const dataSourceBreakdown: Record<string, number> = {};

      // Define current cost tracking period (last month)
      const endDate = new Date();
      const startDate = new Date();
      startDate.setMonth(startDate.getMonth() - 1);

      // Process each team
      for (const team of teams) {
        try {
          const teamCostData = await this.collectTeamCosts(team, startDate, endDate);
          costData.push(teamCostData);
          
          totalCosts += teamCostData.costBreakdown.total;
          
          // Track data sources
          const source = teamCostData.dataSource;
          dataSourceBreakdown[source] = (dataSourceBreakdown[source] || 0) + 1;
          
          // Check budget limits
          const budgetLimit = teamCostData.budgetLimit || this.defaultBudgetLimit;
          if (teamCostData.costBreakdown.total > budgetLimit) {
            teamsOverBudget++;
          }

          // Create criteria update
          const update = this.createCostUpdate(teamCostData);
          updates.push(update);

        } catch (error) {
          this.logger.error(`Failed to collect costs for team ${team.id}:`, error);
          
          // Create error update
          updates.push({
            teamId: team.id,
            criteriaType: 'COST_TRACKING',
            status: 'ERROR',
            score: 0,
            metadata: {
              error: error instanceof Error ? error.message : 'Unknown error',
              timestamp: new Date().toISOString(),
              service: 'CostTrackingService'
            }
          });
        }
      }

      // Update service metrics
      this.metrics = {
        teamsTracked: teams.length,
        totalCosts,
        averageCostPerTeam: teams.length > 0 ? totalCosts / teams.length : 0,
        teamsOverBudget,
        lastUpdateDuration: Date.now() - startTime,
        dataSourceBreakdown
      };

      this.logger.info('Cost tracking completed', {
        teamsTracked: this.metrics.teamsTracked,
        totalCosts: this.metrics.totalCosts,
        averageCostPerTeam: this.metrics.averageCostPerTeam,
        teamsOverBudget: this.metrics.teamsOverBudget,
        duration: this.metrics.lastUpdateDuration
      });

      return updates;
    } catch (error) {
      this.logger.error('Cost tracking failed:', error);
      throw error;
    }
  }

  private async collectTeamCosts(
    team: unknown, 
    startDate: Date, 
    endDate: Date
  ): Promise<TeamCostData> {
    const teamData = team as { id: number; name: string; applicationUrl?: string; memberCount?: number; budgetLimit?: number };
    this.logger.debug(`Collecting costs for team ${teamData.id}: ${teamData.name}`);

    // For now, implement manual/estimated cost tracking
    // In production, this would integrate with cloud provider APIs
    const costBreakdown = await this.getTeamCostBreakdown(teamData, startDate, endDate);
    
    return {
      teamId: teamData.id,
      teamName: teamData.name,
      period: {
        start: startDate,
        end: endDate
      },
      costBreakdown,
      budgetLimit: this.getTeamBudgetLimit(teamData),
      currency: 'USD',
      lastUpdated: new Date(),
      dataSource: this.determineDataSource(teamData)
    };
  }

  private async getTeamCostBreakdown(
    team: { id: number; applicationUrl?: string; memberCount?: number }, 
    startDate: Date, 
    endDate: Date
  ): Promise<CostBreakdown> {
    // Default to estimated costs based on team activity
    // In production, this would query actual cloud provider APIs
    
    const daysInPeriod = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    const dailyEstimate = this.estimateDailyCosts(team);
    
    const compute = dailyEstimate.compute * daysInPeriod;
    const storage = dailyEstimate.storage * daysInPeriod;
    const networking = dailyEstimate.networking * daysInPeriod;
    const database = dailyEstimate.database * daysInPeriod;
    const monitoring = dailyEstimate.monitoring * daysInPeriod;
    const other = dailyEstimate.other * daysInPeriod;
    
    const total = compute + storage + networking + database + monitoring + other;

    this.logger.debug(`Cost breakdown for team ${team.id}:`, {
      compute, storage, networking, database, monitoring, other, total
    });

    return {
      compute: Math.round(compute * 100) / 100,
      storage: Math.round(storage * 100) / 100,
      networking: Math.round(networking * 100) / 100,
      database: Math.round(database * 100) / 100,
      monitoring: Math.round(monitoring * 100) / 100,
      other: Math.round(other * 100) / 100,
      total: Math.round(total * 100) / 100
    };
  }

  private estimateDailyCosts(team: { applicationUrl?: string; memberCount?: number }): CostBreakdown {
    // Basic estimation algorithm based on team characteristics
    // This would be replaced with actual cloud provider cost APIs
    
    const hasApplication = !!team.applicationUrl;
    const teamSize = team.memberCount || 3; // Default team size
    
    // Base costs per day (USD)
    const baseCosts = {
      compute: hasApplication ? 2.5 : 0.5,    // VM/container costs
      storage: hasApplication ? 0.5 : 0.1,    // Storage costs
      networking: hasApplication ? 0.3 : 0.05, // Network costs
      database: hasApplication ? 1.0 : 0.1,   // Database costs
      monitoring: hasApplication ? 0.2 : 0.05, // Monitoring costs
      other: hasApplication ? 0.5 : 0.1       // Miscellaneous
    };
    
    // Scale based on team size (more team members = more resource usage)
    const scalingFactor = Math.min(2.0, 1.0 + (teamSize - 3) * 0.2);
    
    return {
      compute: baseCosts.compute * scalingFactor,
      storage: baseCosts.storage * scalingFactor,
      networking: baseCosts.networking * scalingFactor,
      database: baseCosts.database * scalingFactor,
      monitoring: baseCosts.monitoring * scalingFactor,
      other: baseCosts.other * scalingFactor,
      total: 0 // Will be calculated later
    };
  }

  private getTeamBudgetLimit(team: { budgetLimit?: number }): number {
    // Check if team has a specific budget limit configured
    // This could come from team metadata or configuration
    return team.budgetLimit || this.defaultBudgetLimit;
  }

  private determineDataSource(_team: unknown): TeamCostData['dataSource'] {
    // For now, all data is manual/estimated
    // In production, this would determine the actual data source
    
    // Future logic might check:
    // - If team has cloud provider tags/metadata
    // - If specific cloud provider APIs are configured
    // - If manual cost data is available
    
    return 'manual';
  }

  private createCostUpdate(costData: TeamCostData): CriteriaUpdate {
    const budgetLimit = costData.budgetLimit || this.defaultBudgetLimit;
    const budgetUtilization = (costData.costBreakdown.total / budgetLimit) * 100;
    const isOverBudget = costData.costBreakdown.total > budgetLimit;
    
    // Calculate score based on budget efficiency
    // Lower costs relative to budget = higher score
    let score = 100;
    if (budgetUtilization > 100) {
      // Over budget - penalize heavily
      score = Math.max(0, 100 - ((budgetUtilization - 100) * 2));
    } else if (budgetUtilization > 80) {
      // High utilization - moderate penalty
      score = 100 - ((budgetUtilization - 80) * 2);
    } else {
      // Good utilization - full score
      score = 100;
    }
    
    score = Math.round(score);

    const status = isOverBudget ? 'NEEDS_IMPROVEMENT' : 
                  budgetUtilization > 80 ? 'GOOD' : 'EXCELLENT';

    return {
      teamId: costData.teamId,
      criteriaType: 'COST_TRACKING',
      status,
      score,
      metadata: {
        costBreakdown: costData.costBreakdown,
        budgetLimit,
        budgetUtilization,
        isOverBudget,
        currency: costData.currency,
        period: {
          start: costData.period.start.toISOString(),
          end: costData.period.end.toISOString()
        },
        dataSource: costData.dataSource,
        lastUpdated: costData.lastUpdated.toISOString(),
        timestamp: new Date().toISOString(),
        service: 'CostTrackingService'
      }
    };
  }

  private initializeCloudConfig(): CloudProviderConfig {
    const cloudConfig: CloudProviderConfig = {};
    
    // AWS Configuration
    if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
      cloudConfig.aws = {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
        region: process.env.AWS_REGION || 'us-east-1'
      };
      this.logger.info('AWS cost tracking configured');
    }
    
    // Azure Configuration
    if (process.env.AZURE_CLIENT_ID && process.env.AZURE_CLIENT_SECRET) {
      cloudConfig.azure = {
        clientId: process.env.AZURE_CLIENT_ID,
        clientSecret: process.env.AZURE_CLIENT_SECRET,
        tenantId: process.env.AZURE_TENANT_ID,
        subscriptionId: process.env.AZURE_SUBSCRIPTION_ID
      };
      this.logger.info('Azure cost tracking configured');
    }
    
    // GCP Configuration
    if (process.env.GCP_SERVICE_ACCOUNT_KEY) {
      try {
        const serviceAccountKey = JSON.parse(process.env.GCP_SERVICE_ACCOUNT_KEY);
        cloudConfig.gcp = {
          serviceAccountKey: process.env.GCP_SERVICE_ACCOUNT_KEY,
          projectId: serviceAccountKey.project_id
        };
        this.logger.info('GCP cost tracking configured');
      } catch (error) {
        this.logger.warn('Invalid GCP service account key format');
      }
    }
    
    return cloudConfig;
  }

  evaluateStatus(): ServiceStatus {
    const hasCloudProviders = Object.keys(this.cloudConfig).length > 0;
    const recentlyRun = this.lastSuccessfulRun && 
                       (Date.now() - this.lastSuccessfulRun.getTime()) < 24 * 60 * 60 * 1000;

    const isHealthy = this.metrics.teamsTracked > 0 || recentlyRun;

    let message = '';
    if (!hasCloudProviders) {
      message = 'Manual cost tracking mode (no cloud providers configured)';
    } else {
      message = `Tracking costs for ${this.metrics.teamsTracked} teams`;
    }

    if (this.metrics.teamsOverBudget > 0) {
      message += `, ${this.metrics.teamsOverBudget} teams over budget`;
    }

    return {
      healthy: isHealthy,
      message,
      details: {
        cloudProvidersConfigured: Object.keys(this.cloudConfig),
        defaultBudgetLimit: this.defaultBudgetLimit,
        lastRun: this.lastSuccessfulRun?.toISOString(),
        ...this.metrics
      }
    };
  }
}